// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for SentenceTone.
const (
	SentenceToneCASUAL SentenceTone = "CASUAL"
	SentenceToneFORMAL SentenceTone = "FORMAL"
)

// Defines values for SentenceGroupSort.
const (
	CreatedAtAsc        SentenceGroupSort = "created_at_asc"
	CreatedAtDesc       SentenceGroupSort = "created_at_desc"
	TitleAsc            SentenceGroupSort = "title_asc"
	TitleDesc           SentenceGroupSort = "title_desc"
	TotalReputationAsc  SentenceGroupSort = "total_reputation_asc"
	TotalReputationDesc SentenceGroupSort = "total_reputation_desc"
)

// Defines values for SentenceInputTone.
const (
	SentenceInputToneCASUAL SentenceInputTone = "CASUAL"
	SentenceInputToneFORMAL SentenceInputTone = "FORMAL"
)

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	NextToken *string `json:"nextToken"`
}

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	NextPageToken *openapi_types.UUID `json:"nextPageToken"`
	PageToken     openapi_types.UUID  `json:"pageToken"`
}

// Sentence defines model for Sentence.
type Sentence struct {
	CreatedAt  *time.Time          `json:"created_at,omitempty"`
	GroupId    *openapi_types.UUID `json:"group_id,omitempty"`
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Reputation *int                `json:"reputation,omitempty"`
	TextEn     *string             `json:"text_en,omitempty"`
	TextJp     *string             `json:"text_jp,omitempty"`
	Tone       *SentenceTone       `json:"tone,omitempty"`
}

// SentenceTone defines model for Sentence.Tone.
type SentenceTone string

// SentenceCreate defines model for SentenceCreate.
type SentenceCreate = SentenceInput

// SentenceGroup defines model for SentenceGroup.
type SentenceGroup struct {
	CreatedAt       time.Time          `json:"created_at"`
	Description     string             `json:"description"`
	Id              openapi_types.UUID `json:"id"`
	IsActive        bool               `json:"is_active"`
	Title           string             `json:"title"`
	TotalReputation int                `json:"total_reputation"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

// SentenceGroupInput defines model for SentenceGroupInput.
type SentenceGroupInput struct {
	Description *string `json:"description,omitempty"`
	Title       string  `json:"title"`
}

// SentenceGroupSort defines model for SentenceGroupSort.
type SentenceGroupSort string

// SentenceInput defines model for SentenceInput.
type SentenceInput struct {
	TextEn string            `json:"text_en"`
	TextJp string            `json:"text_jp"`
	Tone   SentenceInputTone `json:"tone"`
}

// SentenceInputTone defines model for SentenceInput.Tone.
type SentenceInputTone string

// PageSize defines model for pageSize.
type PageSize = string

// PaginationToken defines model for paginationToken.
type PaginationToken = string

// GetSentenceGroupsParams defines parameters for GetSentenceGroups.
type GetSentenceGroupsParams struct {
	// PaginationToken Token for pagination
	PaginationToken *PaginationToken `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// PageSize Number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort criteria for sentence groups
	Sort *SentenceGroupSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetSentenceGroupsGroupIdSentencesParams defines parameters for GetSentenceGroupsGroupIdSentences.
type GetSentenceGroupsGroupIdSentencesParams struct {
	// PaginationToken Token for pagination
	PaginationToken *PaginationToken `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// PageSize Number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// PostSentencesGenerateJSONBody defines parameters for PostSentencesGenerate.
type PostSentencesGenerateJSONBody struct {
	Prompt string `json:"prompt"`
	Tone   string `json:"tone"`
}

// PostSentenceGroupsJSONRequestBody defines body for PostSentenceGroups for application/json ContentType.
type PostSentenceGroupsJSONRequestBody = SentenceGroupInput

// PostSentenceGroupsGroupIdSentencesJSONRequestBody defines body for PostSentenceGroupsGroupIdSentences for application/json ContentType.
type PostSentenceGroupsGroupIdSentencesJSONRequestBody = SentenceCreate

// PutSentenceGroupsGroupIdSentencesSentenceIdJSONRequestBody defines body for PutSentenceGroupsGroupIdSentencesSentenceId for application/json ContentType.
type PutSentenceGroupsGroupIdSentencesSentenceIdJSONRequestBody = SentenceInput

// PutSentenceGroupsIdJSONRequestBody defines body for PutSentenceGroupsId for application/json ContentType.
type PutSentenceGroupsIdJSONRequestBody = SentenceGroupInput

// PostSentencesGenerateJSONRequestBody defines body for PostSentencesGenerate for application/json ContentType.
type PostSentencesGenerateJSONRequestBody PostSentencesGenerateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all sentence groups
	// (GET /sentence-groups)
	GetSentenceGroups(ctx echo.Context, params GetSentenceGroupsParams) error
	// Create a new sentence group
	// (POST /sentence-groups)
	PostSentenceGroups(ctx echo.Context) error
	// List all sentences in a group
	// (GET /sentence-groups/{groupId}/sentences)
	GetSentenceGroupsGroupIdSentences(ctx echo.Context, groupId openapi_types.UUID, params GetSentenceGroupsGroupIdSentencesParams) error
	// Create a new sentence in a group
	// (POST /sentence-groups/{groupId}/sentences)
	PostSentenceGroupsGroupIdSentences(ctx echo.Context, groupId openapi_types.UUID) error
	// Delete a sentence by ID
	// (DELETE /sentence-groups/{groupId}/sentences/{sentenceId})
	DeleteSentenceGroupsGroupIdSentencesSentenceId(ctx echo.Context, groupId openapi_types.UUID, sentenceId openapi_types.UUID) error
	// Get a sentence by ID
	// (GET /sentence-groups/{groupId}/sentences/{sentenceId})
	GetSentenceGroupsGroupIdSentencesSentenceId(ctx echo.Context, groupId openapi_types.UUID, sentenceId openapi_types.UUID) error
	// Update a sentence by ID
	// (PUT /sentence-groups/{groupId}/sentences/{sentenceId})
	PutSentenceGroupsGroupIdSentencesSentenceId(ctx echo.Context, groupId openapi_types.UUID, sentenceId openapi_types.UUID) error
	// Increment the reputation of a sentence
	// (POST /sentence-groups/{groupId}/sentences/{sentenceId}/reputation:increment)
	PostSentenceGroupsGroupIdSentencesSentenceIdReputationIncrement(ctx echo.Context, groupId openapi_types.UUID, sentenceId openapi_types.UUID) error
	// Delete a sentence group by ID
	// (DELETE /sentence-groups/{id})
	DeleteSentenceGroupsId(ctx echo.Context, id openapi_types.UUID) error
	// Get a sentence group by ID
	// (GET /sentence-groups/{id})
	GetSentenceGroupsId(ctx echo.Context, id openapi_types.UUID) error
	// Update a sentence group by ID
	// (PUT /sentence-groups/{id})
	PutSentenceGroupsId(ctx echo.Context, id openapi_types.UUID) error
	// Generate sentences based on prompt and tone by LLM
	// (POST /sentences:generate)
	PostSentencesGenerate(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetSentenceGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetSentenceGroups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSentenceGroupsParams
	// ------------- Optional query parameter "paginationToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "paginationToken", ctx.QueryParams(), &params.PaginationToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter paginationToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSentenceGroups(ctx, params)
	return err
}

// PostSentenceGroups converts echo context to params.
func (w *ServerInterfaceWrapper) PostSentenceGroups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSentenceGroups(ctx)
	return err
}

// GetSentenceGroupsGroupIdSentences converts echo context to params.
func (w *ServerInterfaceWrapper) GetSentenceGroupsGroupIdSentences(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSentenceGroupsGroupIdSentencesParams
	// ------------- Optional query parameter "paginationToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "paginationToken", ctx.QueryParams(), &params.PaginationToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter paginationToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSentenceGroupsGroupIdSentences(ctx, groupId, params)
	return err
}

// PostSentenceGroupsGroupIdSentences converts echo context to params.
func (w *ServerInterfaceWrapper) PostSentenceGroupsGroupIdSentences(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSentenceGroupsGroupIdSentences(ctx, groupId)
	return err
}

// DeleteSentenceGroupsGroupIdSentencesSentenceId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSentenceGroupsGroupIdSentencesSentenceId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "sentenceId" -------------
	var sentenceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sentenceId", ctx.Param("sentenceId"), &sentenceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sentenceId: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSentenceGroupsGroupIdSentencesSentenceId(ctx, groupId, sentenceId)
	return err
}

// GetSentenceGroupsGroupIdSentencesSentenceId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSentenceGroupsGroupIdSentencesSentenceId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "sentenceId" -------------
	var sentenceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sentenceId", ctx.Param("sentenceId"), &sentenceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sentenceId: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSentenceGroupsGroupIdSentencesSentenceId(ctx, groupId, sentenceId)
	return err
}

// PutSentenceGroupsGroupIdSentencesSentenceId converts echo context to params.
func (w *ServerInterfaceWrapper) PutSentenceGroupsGroupIdSentencesSentenceId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "sentenceId" -------------
	var sentenceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sentenceId", ctx.Param("sentenceId"), &sentenceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sentenceId: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutSentenceGroupsGroupIdSentencesSentenceId(ctx, groupId, sentenceId)
	return err
}

// PostSentenceGroupsGroupIdSentencesSentenceIdReputationIncrement converts echo context to params.
func (w *ServerInterfaceWrapper) PostSentenceGroupsGroupIdSentencesSentenceIdReputationIncrement(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "sentenceId" -------------
	var sentenceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sentenceId", ctx.Param("sentenceId"), &sentenceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sentenceId: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSentenceGroupsGroupIdSentencesSentenceIdReputationIncrement(ctx, groupId, sentenceId)
	return err
}

// DeleteSentenceGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSentenceGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSentenceGroupsId(ctx, id)
	return err
}

// GetSentenceGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSentenceGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSentenceGroupsId(ctx, id)
	return err
}

// PutSentenceGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) PutSentenceGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutSentenceGroupsId(ctx, id)
	return err
}

// PostSentencesGenerate converts echo context to params.
func (w *ServerInterfaceWrapper) PostSentencesGenerate(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSentencesGenerate(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/sentence-groups", wrapper.GetSentenceGroups)
	router.POST(baseURL+"/sentence-groups", wrapper.PostSentenceGroups)
	router.GET(baseURL+"/sentence-groups/:groupId/sentences", wrapper.GetSentenceGroupsGroupIdSentences)
	router.POST(baseURL+"/sentence-groups/:groupId/sentences", wrapper.PostSentenceGroupsGroupIdSentences)
	router.DELETE(baseURL+"/sentence-groups/:groupId/sentences/:sentenceId", wrapper.DeleteSentenceGroupsGroupIdSentencesSentenceId)
	router.GET(baseURL+"/sentence-groups/:groupId/sentences/:sentenceId", wrapper.GetSentenceGroupsGroupIdSentencesSentenceId)
	router.PUT(baseURL+"/sentence-groups/:groupId/sentences/:sentenceId", wrapper.PutSentenceGroupsGroupIdSentencesSentenceId)
	router.POST(baseURL+"/sentence-groups/:groupId/sentences/:sentenceId/reputation:increment", wrapper.PostSentenceGroupsGroupIdSentencesSentenceIdReputationIncrement)
	router.DELETE(baseURL+"/sentence-groups/:id", wrapper.DeleteSentenceGroupsId)
	router.GET(baseURL+"/sentence-groups/:id", wrapper.GetSentenceGroupsId)
	router.PUT(baseURL+"/sentence-groups/:id", wrapper.PutSentenceGroupsId)
	router.POST(baseURL+"/sentences:generate", wrapper.PostSentencesGenerate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
